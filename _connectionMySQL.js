'use strict'
//TODO ponernos con esto tras puppeteer mensajes pulido.
var mysql      = require('mysql');
var connection = mysql.createConnection({
  host     : '127.0.0.1',
  user     : 'root',
  password : 'root',
  database : 'messengerbots2'
});

/*var options = {
  encoding: 'utf8'
};*/

/**
 * saves message sent to bot, and the time it takes to respond it. 
 **
 * @param  {String} - botId - messenger id of the bot.
 * @param  {number} - timeUntilResponse - time in seconds up to 3 decimal positions. xx.yyy
 * @param  {String} - messageSent - message sent to the bot, if button pressed content of the button, if multimedia (image, audio), null.
 * @param  {boolean} - buttonPressed - indicates that a button triggered the response.
 * @param  {boolean} - multimediaMessage - indicates that a multimedia message triggered the response.
 * @param {date} - date - date of the analysis.
 * 
 * @returns {String/int?} - id autogenerated by mysql.  
 */

//TODO fix date en tablas sql, y en este método.
function saveMessageSent(botId, timeUntilResponse, messageSent, buttonPressed, multimediaMessage,date){
	return new Promise(function(resolve,reject){
		connection.query('insert into messagesenttobot(botId, timeUntilResponse, messageSent, buttonPressed, multimediaMessage) values ("'+botId+'","'+timeUntilResponse +'","'+messageSent+'",'+buttonPressed+','+ multimediaMessage+');', 
		function (error, results, fields) {
			if (error) {
			  return connection.rollback(function() {
				reject(error);
			  });
			}else{
				var autogeneratedId = connection.query('SELECT SCOPE_IDENTITY();',
				function (error, results, fields) {
					if(error){
						reject(error);
					}
					resolve(autogeneratedId);
				});
			}
		});
	});
}

/**
 * saves response received from bot, individual message.
 **
 * @param  {String} - botId - messenger id of the bot that responded.
 * @param  {String} - idMessageSent - DB id of the message sent, of which this is response.
 * @param  {boolean} - multimediaResponse - indicates that a multimedia response has been received (image,audio, video).
 * @param  {boolean} - containsEmojis - indicates that the response contains emojis.
 * @param  {boolean} - isButton - indicates that the response is a button.
 * @param  {String} - responseText - text received from the bot, if multimedia null.
 * @param  {String} - the response saved in json.
 */

function saveResponse(botId, idMessageSent, multimediaResponse, containsEmojis, isButton, responseText){
	return new Promise(function(resolve,reject){

		connection.query('insert into botresponse(botid, idmessagesent, multimediaresponse, containsemojis, isbutton, responsetext) values ("'+botId+'","'+idMessageSent +'",'+multimediaResponse+','+containsEmojis+','+ isButton+',"' +responseText+ '");', 
		function (error, results, fields) {
			if (error) {
			  return connection.rollback(function() {
				reject(error);
			  });
			}else{
				resolve();
			}
		});
	});
}

/**
 * saves bot info. If bot already exists, updates its info.
 **
 * @param  {String} - id - botId, messenger id of the bot. If registry already exists, it is updated.
 * @param  {Object} - data - the data we have about the bot. We can have missing keys inside this object.
 *    @param  {String} - name - bot Name.
 *    @param  {boolean} - connect - if the bot is reachable or not.
 *    @param  {String} - likes - number of bot likes.

 */
function saveBotInfo(botData){ // commands,){
	return new Promise(function(resolve,reject){
		connection.query('Select * from bots where id="' + botData.id +'";', function(error, results, fields){
			
			//1. Procesamos información del objeto botData para almacenarla.
			var data = Object.assign({},botData);
			delete data.messages;
			for(var key in data.basicInfo){
				data[key] = data.basicInfo[key];
			}
			delete data.basicInfo;
			for(var key in data.reviewedFeatures){
				data[key] = data.reviewedFeatures[key];
			}
			delete data.reviewedFeatures;
			data.emojisPercentage = (data.emojis.numYes / data.emojis.numNo + data.emojis.numYes) || 0;
			delete data.emojis;
			data.multimediaPercentage = (data.multimedia.numYes / data.multimedia.numNo + data.multimedia.numYes) || 0;
			delete data.multimedia;
			var params = [];
			for(var key in data){
				params.push(key);
			}
			var values = [];
			for(var key in data){
				var value = data[key];
				if((typeof value !== typeof true)&&(typeof value !== typeof 1)){value = '"'+value+'"';}
				values.push(value);
			};
		
			//2. Almacenamos la información.
			if(!error){
				if(!results.length){

					params = params.join(",");
					values = values.join(",");

					connection.query('insert into bots('+params+') values ('+values+');', function (error, results, fields) {
						if (error) {
						  return connection.rollback(function() {
							reject(error);
						  });
						}else{
							resolve();
						}
					});
				}else{
					var keyAndValues =[];
					for(var i=0;i<params.length;i++){
						keyAndValues.push(params[i]+"= "+values[i]);
					}
					keyAndValues = keyAndValues.join(",");
					connection.query('update bots set '+ keyAndValues +' WHERE id = "'+botData.id+'" ;', function (error, results, fields) {
						if (error) {
						  return connection.rollback(function() {
							reject();
						  });
						}else{
							resolve();
						}
					});
				}
			}
		});
	});
}

function checkBotsTable(){
	return new Promise(function(resolve,reject){
		connection.query('Describe bots;', function(error, results, fields){
			if(error){
				connection.query('CREATE TABLE bots(id VARCHAR(15) NOT NULL, name VARCHAR(25),likes INT(15),respond TINYINT(1), initialButton TINYINT(1), initialMsgUseful TINYINT(1), helpCommand TINYINT(1),variation TINYINT(1),typosHandled TINYINT(1),buttonEquivalent TINYINT(1), emojisPercentage DECIMAL(2,2),multimediaPercentage DECIMAL(2,2),PRIMARY KEY(id));'
				,function(error,results,fields){
					if(error){
						reject();
					}else{
						resolve();
					}
				});
			}else{
				resolve();
			}
		});
	});
}


function endConnection(){
	connection.end();
}

module.exports = {
	saveBotInfo : saveBotInfo,
	endConnection:endConnection,
	saveMessageSent: saveMessageSent,
	saveResponse: saveResponse,
	checkBotsTable: checkBotsTable
};
//no hace falta realizar connection.connect(), con createConnection vale,
// y tampoco connection.end() tras cada operación de DB, con realizar una vez al terminar correcto.