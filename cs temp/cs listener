function listenBotResponse(page){
  return new Promise(function(resolve,reject){
    (async ()=>{

      try{  
        var result = await page.evaluate(function(processNodeDataStr,processBottomButtonsStr,getPathStr){//timestamp1){

          //un-serialize helper functions.
          const processNodeData = new Function(' return (' + processNodeDataStr + ').apply(null, arguments)');
          const processBottomButtons = new Function(' return (' + processBottomButtonsStr + ').apply(null, arguments)');
          const getPath = new Function(' return (' + getPathStr + ').apply(null, arguments)');


          var promiseMessages =  new Promise(function(resolve,reject){
            try{
              var box = document.querySelector("div[role='presentation']");
              var closerBox = box.querySelector("div[role='region']");
              var messagesBox = closerBox.querySelector("div[id]");
            }catch(e){
              reject(e);
            }
            
            var elapsedTime;
            var insertedNodes = [];
            var processedNodes = [];
            //var ignoredMessages = 0; //En browser es necesario, puesto que llegan 2 que no necesitamos (tiempo y msg nuestro), en puppeteer llegan los útiles.
            var settedTimeouts = [];
            var timestamp1 = new Date();
            var botResponse = false;
            var mutationObserver = new MutationObserver(function(mutations) {
              mutations.forEach(function(mutation) {
                
                //if(ignoredMessages<2){
                //  ignoredMessages++;
                //}else{ //ignoramos hora en la que se ha enviado el mensaje y nuestro mensaje. // otra forma de ignorar primer mensaje.
                //if(mutation.addedNodes.length){ //ignoramos primer mensaje. NO VALE.
                  console.log('#1');
                  if(!elapsedTime){var elapsedTime = (new Date()-timestamp1)/1000;} //referencia temporal primer mensaje devuelto por el bot.
                  insertedNodes = insertedNodes.concat(mutation.addedNodes[0]);
                  botResponse = true;
                  console.log("#2");
                  var temporizer = setTimeout(()=>{
                    //TODO esto no hará que se pare en cuanto llegue primer mensaje?
                    mutationObserver.disconnect();
                    try{
                      insertedNodes = insertedNodes.filter((node)=>{if(node){return node;}}); //eliminamos undefined s.
                      console.log("#3");
                      processedNodes = insertedNodes.map((node)=>{return processNodeData(node,getPath);});
                      console.log("#4");
                      processedNodes = processedNodes.filter((node)=>{if(node.length){return node;}});
                    }catch(err){
                      console.log("BIG PROBLEM");
                      console.log(err);
                    };
                    //console.log(processedNodes);
                    resolve({time: elapsedTime,nodes: processedNodes});
                    
                  },7000);
                //}
              });
            });
            mutationObserver.observe(messagesBox, { childList: true });
            setTimeout(()=>{
              if(!botResponse){
                //console.log("Reached 7 secs.");
                mutationObserver.disconnect(); resolve({time: 7000,nodes: processedNodes});
              }
            },7000);
           
          });

          var promiseBottomButtons = new Promise(function(resolve,reject){
            try{
              var box = document.querySelector("div[role='presentation']");
              var closerBox = box.querySelector("div[class]"); //selecciona la primera capa que encuentra (la más exterior dentro de box).
              //console.log(closerBox._args);//TODO ver hmtl seleccionado...
            }catch(e){
              reject(e);
              return;
            }
            var elapsedTime;
            //var insertedNodes = [];
            //var processedNodes = [];
            //var settedTimeouts = [];
            var timestamp1 = new Date();
            var bottomButtons = [];
            var mutationObserver = new MutationObserver(function(mutations) {
              mutations.forEach(function(mutation) {
                  bottomButtons =processBottomButtons(mutation.addedNodes[0],getPath);
                  if(bottomButtons.length){
                    if(!elapsedTime){var elapsedTime = (new Date()-timestamp1)/1000;} //referencia temporal primer mensaje devuelto por el bot.
                    mutationObserver.disconnect();
                    resolve({time: elapsedTime,nodes: bottomButtons});
                  }
              });
            });
            mutationObserver.observe(closerBox, { childList: true });
            setTimeout(()=>{
              if(!bottomButtons.length){
                //console.log("Reached 7 secs ."); 
                mutationObserver.disconnect(); resolve({time: 7000,nodes: []});
              }
            },7000);
           
          });

          return Promise.all([
            promiseMessages,
            promiseBottomButtons
          ]);
        }, processNodeData.toString(), processBottomButtons.toString(), getPath.toString()); //helper functions, serialized.
      }catch(err){
        reject(err);
      }

      resolve(result);
      
    })();
  });
}